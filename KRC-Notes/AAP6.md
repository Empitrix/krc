## Conditional Compilation
Parts of a program may be compiled conditionally, according to the following schematic syntax.

```text
preprocessor-conditional:
  if-line text elif-parts else-part(opt) #endif

if-line:
  # if constant-expression
  # ifdef identifier
  # ifndef identifier

elif-parts:
  elif-line text
  elif-partsopt

elif-line:
  # elif constant-expression

else-part:
  else-line text

else-line:
  #else
```

Each of the directives (`if-line`, `elif-line`, `else-line`, and `#endif`) appears alone on a line.

The constant expressions in #if and subsequent #elif lines are evaluated in order until an expression with a non-zero value is found; text following a line with a zero value is discarded.

Once a successful `#if` or `#elif` line has been found and its text processed, succeeding `#elif` and `#else` lines, together with their text, are discarded.

If all the expressions are zero, and there is an `#else`, the text following the `#else` is treated normally. Text controlled by inactive arms of the conditional is ignored except for checking the nesting of conditionals.

The constant expression in `#if` and `#elif` is subject to ordinary macro replacement.
Moreover, any expressions of the form
```c
defined identifier
// or
defined (identifier)
```
are replaced, before scanning for macros, by `1L` if the identifier is defined in the preprocessor, and by `0L` if not. Any identifiers remaining after macro expansion are replaced by `0L`. Finally, each integer constant is considered to be suffixed with `L`, so that all arithmetic is taken to be long or unsigned long.

it must be integral, and may not contain `sizeof`, a cast, or an enumeration constant.

The control lines
```c
#ifdef identifier
#ifndef identifier
```
are equivalent to
```c
# if defined identifier
# if ! defined identifier
```

### Line Control
For the benefit of other preprocessors that generate C programs, a line in one of the forms
```c
# line constant "filename"
# line constant
```
causes the compiler to believe, for purposes of error diagnostics, that the line number of the next source line is given by the decimal integer constant and the current input file is named by the identifier. If the quoted filename is absent, the remembered name does not change. Macros in the line are expanded before it is interpreted.


### Error Generation
A preprocessor line of the form
```c
# error token-sequence(opt)
```
causes the preprocessor to write a diagnostic message that includes the token sequence.

### Pragmas
A control line of the form
```c
# pragma token-sequence(opt)
```
causes the preprocessor to perform an implementation-dependent action. An unrecognized pragma is ignored.

### Null directive
A control line of the form
```c
#
```
has no effect.


### Predefined names
Several identifiers are predefined, and expand to produce special information. They, and also the preprocessor expansion operator `defined`, may not be undefined or redefined.

- `__LINE__`: A decimal constant containing the current source line number.
- `__FILE__`: A string literal containing the name of the file being compiled.
- `__DATE__`: A string literal containing the date of compilation, in the form `"Mmmm dd yyyy"`
- `__TIME__`: A string literal containing the time of compilation, in the form `"hh:mm:ss"`.
- `__STDC__`: The constant `1`, It is intended that this identifier be defined to be `1` only in standard-conforming implementations.

```NOTE
#error and #pragma are new with the ANSI standard; the predefined preprocessor macros are new, but some of them have been available in some implementations.
```

## Grammer
Below is a recapitulation of the grammar that was given throughout the earlier part of this appendix. It has exactly the same content, but is in different order.

The grammar has undefined terminal symbols *integer-constant*, *character-constant*, *floating-constant*, *identifier*, *string*, and *enumeration-constant*; the `typewriter` style words and symbols are terminals given literally. This grammar can be transformed mechanically into input acceptable for an automatic parser-generator. Besides adding whatever syntactic marking is used to indicate alternatives in productions, it is necessary to expand the `one of` constructions, and (depending on the rules of the parser-generator) to duplicate each production with an opt symbol, once with the symbol and once without. With one further change, namely deleting the production *typedef-name*: *identifier* and making *typedef-name* a terminal symbol, this grammar is acceptable to the YACC parser-generator. It has only one conflict, generated by the `if-else` ambiguity.

---

```grammer
translation-unit:
    external-declaration
    translation-unit external-declaration

external-declaration:
    function-definition
    declaration

function-definition:
    declaration-specifiers opt declarator declaration-list opt compound-statement

declaration:
    declaration-specifiers init-declarator-list opt ;

declaration-list:
    declaration
    declaration-list declaration

declaration-specifiers:
    storage-class-specifier declaration-specifiers opt
    type-specifier declaration-specifiers opt
    type-qualifier declaration-specifiers opt

storage-class specifier: one of
    auto register static extern typedef

type specifier: one of
    void char short int long float double signed unsigned struct-or-union-specifier enum-specifier typedef-name


type-qualifier: one of
    const volatile

struct-or-union-specifier:
    struct-or-union identifier opt { struct-declaration-list }
    struct-or-union identifier

struct-or-union: one of
    struct union

struct-declaration-list:
    struct declaration
    struct-declaration-list struct declaration

init-declarator-list:
    init-declarator
    init-declarator-list, init-declarator

init-declarator:
    declarator
    declarator = initializer

struct-declaration:
    specifier-qualifier-list struct-declarator-list ;

specifier-qualifier-list:
    type-specifier specifier-qualifier-list opt
    type-qualifier specifier-qualifier-list opt

struct-declarator-list:
    struct-declarator
    struct-declarator-list , struct-declarator

struct-declarator:
    declarator
    declarator opt : constant-expression

enum-specifier:
    enum identifier opt { enumerator-list }
    enum identifier

enumerator-list:
    enumerator
    enumerator-list , enumerator

enumerator:
    identifier
    identifier = constant-expression

declarator:
    pointer opt direct-declarator

direct-declarator:
    identifier
    ( declarator )
    direct-declarator [ constant-expression opt ]

direct-declarator ( parameter-type-list )
direct-declarator ( identifier-list opt )

pointer:
  * type-qualifier-list opt
  * type-qualifier-list opt pointer

type-qualifier-list:
  type-qualifier
  type-qualifier-list type-qualifier

parameter-type-list:
  parameter-list
  parameter-list , ...

parameter-list:
  parameter-declaration
  parameter-list , parameter-declaration

parameter-declaration:
  declaration-specifiers declarator
  declaration-specifiers abstract-declarator opt

identifier-list:
  identifier
  identifier-list , identifier

initializer:
  assignment-expression
  { initializer-list }
  { initializer-list , }

initializer-list:
  initializer
  initializer-list , initializer

type-name:
  specifier-qualifier-list abstract-declarator opt

abstract-declarator:
  pointer
  pointer opt direct-abstract-declarator

direct-abstract-declarator:
  ( abstract-declarator )
  direct-abstract-declarator opt [constant-expression opt]
  direct-abstract-declarator opt (parameter-type-list opt) 

typedef-name:
  identifier

statement:
  labeled-statement
  expression-statement
  compound-statement
  selection-statement

iteration-statement
jump-statement

labeled-statement:
  identifier : statement
  case constant-expression : statement
  default : statement

expression-statement:
  expression opt;

compound-statement:
  { declaration-listopt statement-listopt }

statement-list:
  statement
  statement-list statement

selection-statement:
  if (expression) statement
  if (expression) statement else statement
  switch (expression) statement

iteration-statement:
  while (expression) statement
  do statement while (expression);
  for (expression opt; expression opt; expression opt) statement

jump-statement:
  goto identifier;
  continue;
  break;
  return expression opt;

expression:
  assignment-expression
  expression , assignment-expression

assignment-expression:
  conditional-expression
  unary-expression assignment-operator assignment-expression
  assignment-operator: one of
  = *= /= %= += -= <<= >>= &= ^= |=

conditional-expression:
  logical-OR-expression
  logical-OR-expression ? expression : conditional-expression

constant-expression:
  conditional-expression

logical-OR-expression:
  logical-AND-expression
  logical-OR-expression || logical-AND-expression

logical-AND-expression:
  inclusive-OR-expression
  logical-AND-expression && inclusive-OR-expression

inclusive-OR-expression:
  exclusive-OR-expression
  inclusive-OR-expression | exclusive-OR-expression

exclusive-OR-expression:
  AND-expression
  exclusive-OR-expression ^ AND-expression

AND-expression:
  equality-expression
  AND-expression & equality-expression

equality-expression:
  relational-expression
  equality-expression == relational-expression
  equality-expression != relational-expression

relational-expression:
  shift-expression
  relational-expression < shift-expression
  relational-expression > shift-expression
  relational-expression <= shift-expression
  relational-expression >= shift-expression

shift-expression:
  additive-expression
  shift-expression << additive-expression
  shift-expression >> additive-expression

additive-expression:
  multiplicative-expression
  additive-expression + multiplicative-expression
  additive-expression - multiplicative-expression

multiplicative-expression:
  multiplicative-expression * cast-expression
  multiplicative-expression / cast-expression
  multiplicative-expression % cast-expression

cast-expression:
  unary expression
  (type-name) cast-expression

unary-expression:
  postfix expression
  ++unary expression
  --unary expression
  unary-operator cast-expression
  sizeof unary-expression
  sizeof (type-name) 

unary operator: one of
  & * + - ~ !

postfix-expression:
  primary-expression
  postfix-expression[expression]
  postfix-expression(argument-expression-listopt)
  postfix-expression.identifier
  postfix-expression->+identifier
  postfix-expression++
  postfix-expression--

primary-expression:
  identifier
  constant
  string
  (expression)

argument-expression-list:
  assignment-expression
  assignment-expression-list , assignment-expression

constant:
  integer-constant
  character-constant
  floating-constant
  enumeration-constant
```

The following grammar for the preprocessor summarizes the structure of control lines, but is not suitable for mechanized parsing. It includes the symbol text, which means ordinary program text, non-conditional preprocessor control lines, or complete preprocessor conditional instructions.

```text
control-line:
  # define identifier token-sequence
  # define identifier(identifier, ... , identifier) token-sequence
  # undef identifier
  # include <filename>
  # include "filename"
  # line constant "filename"
  # line constant
  # error token-sequenceopt
  # pragma token-sequenceopt
  #
  preprocessor-conditional

preprocessor-conditional:
  if-line text elif-parts else-part opt #endif

if-line:
  # if constant-expression
  # ifdef identifier
  # ifndef identifier

elif-parts:
  elif-line text
  elif-parts opt

elif-line:
  # elif constant-expression

else-part:
  else-line text

else-line:
  #else
```
